#include "Font.h"
#include <cstring>

//static members
FT_Library FTLibraryContainer::library_;
FTLibraryContainer Font::library_;

/* FTLibraryContainer implementation */

FTLibraryContainer::FTLibraryContainer()
{
    if (FT_Init_FreeType(&library_) != 0)
    {
        throw std::runtime_error("Could not initialize FreeType2 library.");
    }
}

FTLibraryContainer::~FTLibraryContainer()
{
    FT_Done_FreeType(library_);
}

FT_Library& FTLibraryContainer::getLibrary()
{
    return library_;
}

/* Font implementation */

Font::Font() :
    texID_(0), listBase_(0),    // initalize GL variables to zero
    widths_(NUM_CHARS),         // make room for 96 widths
    height_(0)
{
}

Font::Font(const std::string& filename, unsigned int size) :
    texID_(0), listBase_(0),    // initalize GL variables to zero
    widths_(NUM_CHARS),         // make room for 96 widths
    height_(0)
{
    Open(filename, size);
}

Font::~Font()
{
    Release();
}

void Font::Open(const std::string& filename, unsigned int size)
{
    const size_t MARGIN = 3;

    // release the font if it already exists
    if(IsValid())
    {
        Release();
    }
    // Step 1: Open the font using FreeType //
    FT_Face face;

    if(FT_New_Face(library_.getLibrary(), filename.c_str(), 0, &face) != 0)
    {
        throw std::runtime_error("Could not load font file.");
    }
    // Abort if this is not a scalable font.
    if(!(face->face_flags & FT_FACE_FLAG_SCALABLE) ||
            !(face->face_flags & FT_FACE_FLAG_HORIZONTAL))
    {
        throw std::runtime_error("Invalid font: Error setting font size.");
    }

    // Set the font size
    FT_Set_Pixel_Sizes(face, size, 0);

    // Step 2: Find maxAscent/Descent to calculate imageHeight //
    size_t imageHeight = 0;
    size_t imageWidth = 256;
    int maxDescent = 0;
    int maxAscent = 0;
    size_t lineSpace = imageWidth - MARGIN;
    size_t lines = 1;
    size_t charIndex;

    for(unsigned int ch = 0; ch < NUM_CHARS; ++ch)
    {
        // Look up the character in the font file.
        charIndex = FT_Get_Char_Index(face, ch+SPACE);

        // Render the current glyph.
        FT_Load_Glyph(face, charIndex, FT_LOAD_RENDER);

        widths_[ch] = (face->glyph->metrics.horiAdvance >> 6) + MARGIN;
        // If the line is full go to the next line
        if(widths_[ch] > lineSpace)
        {
            lineSpace = imageWidth - MARGIN;
            ++lines;
        }
        lineSpace -= widths_[ch];

        maxAscent = std::max(face->glyph->bitmap_top, maxAscent);
        maxDescent = std::max(face->glyph->bitmap.rows -
                              face->glyph->bitmap_top, maxDescent);
    }

    height_ = maxAscent + maxDescent;   // calculate height_ for text

    // Compute how high the texture has to be.
    size_t neededHeight = (maxAscent + maxDescent + MARGIN) * lines + MARGIN;
    // Get the first power of two in which it will fit
    imageHeight = 16;
    while(imageHeight < neededHeight)
    {
        imageHeight <<= 1;
    }

    // Step 3: Generation of the actual texture //

    // create and zero the memory
    unsigned char* image = new unsigned char[imageHeight * imageWidth];
    memset(image, 0, imageHeight * imageWidth);

    // These are the position at which to draw the next glyph
    size_t x = MARGIN;
    size_t y = MARGIN + maxAscent;
    float texX1, texX2, texY1, texY2;   // used for display list

    listBase_ = glGenLists(NUM_CHARS);  // generate the lists for filling

    // Drawing loop
    for(unsigned int ch = 0; ch < NUM_CHARS; ++ch)
    {
        size_t charIndex = FT_Get_Char_Index(face, ch+SPACE);

        // Render the glyph
        FT_Load_Glyph(face, charIndex, FT_LOAD_DEFAULT);
        FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);

        // See whether the character fits on the current line
        if(widths_[ch] > imageWidth - x)
        {
            x = MARGIN;
            y += (maxAscent + maxDescent + MARGIN);
        }

        // calculate texture coordinates of the character
        texX1 = static_cast<float>(x) / imageWidth;
        texX2 = static_cast<float>(x+widths_[ch]) / imageWidth;
        texY1 = static_cast<float>(y - maxAscent) / imageHeight;
        texY2 = texY1 + static_cast<float>(height_) / imageHeight;

        // generate the character's display list
        glNewList(listBase_ + ch, GL_COMPILE);
        glBegin(GL_QUADS);
        glTexCoord2f(texX1,texY1);
        glVertex2i(0,0);
        glTexCoord2f(texX2,texY1);
        glVertex2i(widths_[ch],0);
        glTexCoord2f(texX2,texY2);
        glVertex2i(widths_[ch],height_);
        glTexCoord2f(texX1,texY2);
        glVertex2i(0,height_);
        glEnd();
        glTranslatef(widths_[ch],0,0);  // translate forward
        glEndList();

        // copy image generated by FreeType to the texture
        for(int row = 0; row < face->glyph->bitmap.rows; ++row)
        {
            for(int pixel = 0; pixel < face->glyph->bitmap.width; ++pixel)
            {
                // set pixel at position to intensity (0-255) at the position
                image[(x + face->glyph->bitmap_left + pixel) +
                      (y - face->glyph->bitmap_top + row) * imageWidth] =
                          face->glyph->bitmap.buffer[pixel +
                                                     row * face->glyph->bitmap.pitch];
            }
        }

        x += widths_[ch];
    }

    // generate the OpenGL texture from the byte array
    glGenTextures(1, &texID_);
    glBindTexture(GL_TEXTURE_2D, texID_);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA8, imageWidth, imageHeight, 0,
                 GL_ALPHA, GL_UNSIGNED_BYTE, image);

    delete[] image;     // now done with the image memory
    FT_Done_Face(face); // free the face data
}

void Font::Release()
{
    if(glIsList(listBase_))
    {
        glDeleteLists(listBase_, NUM_CHARS);
    }
    if(glIsTexture(texID_))
    {
        glDeleteTextures(1, &texID_);
    }

    // clear out data
    texID_ = 0;
    listBase_ = 0;
    widths_.clear();
    widths_.resize(NUM_CHARS);
    height_ = 0;
}

bool Font::IsValid() const
{
    return glIsTexture(texID_) == GL_TRUE;
}


const GLuint Font::CalcStringWidth(const std::string& str) const
{
    if(!IsValid())
    {
        throw std::logic_error("Invalid Font::calcStringWidth call.");
    }
    unsigned int width=0;

    // iterate through widths of each char and accumulate width of string
    for(std::string::const_iterator i = str.begin(); i < str.end(); ++i)
    {
        width += widths_[static_cast<unsigned int>(*i) - SPACE];
    }

    return width;
}

const GLuint Font::GetHeight() const
{
    if(!IsValid())
    {
        throw std::logic_error("Invalid Font::getHeight call.");
    }
    return height_;
}

const GLuint Font::GetTexture() const
{
    return texID_;
}

const GLuint Font::GetListBase() const
{
    return listBase_;
}
